#!/usr/bin/env python3
"""Start a new Android QA recording session."""

import argparse
import json
import os
import re
import shutil
import sys
import warnings
from datetime import datetime


BASE_DIR = ".android-qa"
LOCK_FILE = os.path.join(BASE_DIR, "active-session.json")
RECORDINGS_DIR = "recordings"


def utcnow():
    """Get current UTC time (suppresses deprecation warning on Python 3.12+)."""
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", DeprecationWarning)
        return datetime.utcnow()


def format_timestamp(dt):
    """Format a datetime as ISO 8601 with millisecond precision."""
    return dt.strftime("%Y-%m-%dT%H:%M:%S.") + dt.strftime("%f")[:3] + "Z"


def finalize_session(lock_data):
    """Finalize the current recording session: convert .jsonl to .json and clean up."""
    session_name = lock_data["session_name"]
    jsonl_path = lock_data["output_path"]
    session_dir = os.path.join(RECORDINGS_DIR, session_name)
    json_path = os.path.join(session_dir, "recording.json")

    commands = []
    if os.path.exists(jsonl_path):
        with open(jsonl_path, "r") as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue
                try:
                    commands.append(json.loads(line))
                except json.JSONDecodeError:
                    print(
                        "Warning: skipping corrupt line %d in %s"
                        % (line_num, jsonl_path),
                        file=sys.stderr,
                    )

    started_at = lock_data.get("started_at", format_timestamp(utcnow()))
    if commands:
        started_at = commands[0]["issued_at"]
        completed_at = commands[-1]["issued_at"]
    else:
        completed_at = started_at

    # Find the last screenshot: look for the last pull that follows a screencap
    golden_screenshot = None
    for i in range(len(commands) - 1, 0, -1):
        cmd_args = commands[i]["args"]
        prev_args = commands[i - 1]["args"]
        if (
            len(cmd_args) >= 3
            and cmd_args[0] == "pull"
            and len(prev_args) >= 2
            and prev_args[0] == "shell"
            and prev_args[1] == "screencap"
        ):
            local_path = cmd_args[-1]
            if os.path.exists(local_path):
                golden_dest = os.path.join(session_dir, "golden.png")
                shutil.copy2(local_path, golden_dest)
                golden_screenshot = "golden.png"
            break

    metadata = {
        "name": session_name,
        "started_at": started_at,
        "completed_at": completed_at,
        "command_count": len(commands),
    }
    if golden_screenshot:
        metadata["golden_screenshot"] = golden_screenshot
    prompt = lock_data.get("prompt")
    if prompt:
        metadata["prompt"] = prompt
    device_serial = lock_data.get("device_serial")
    if device_serial:
        metadata["device_serial"] = device_serial
    if lock_data.get("performance_tracking"):
        metadata["performance_tracking"] = True
    if lock_data.get("perfetto_tracing"):
        metadata["perfetto_tracing"] = True

    recording = {
        "metadata": metadata,
        "commands": commands,
    }

    os.makedirs(session_dir, exist_ok=True)
    with open(json_path, "w") as f:
        json.dump(recording, f, indent=2)
        f.write("\n")

    if os.path.exists(jsonl_path):
        os.remove(jsonl_path)
    if os.path.exists(LOCK_FILE):
        os.remove(LOCK_FILE)

    return len(commands)


def main():
    parser = argparse.ArgumentParser(description="Start a new Android QA recording session.")
    parser.add_argument("session_name", help="Name for the recording session")
    parser.add_argument("--prompt", help="Original test scenario prompt")
    parser.add_argument("--device", help="ADB device serial (from adb devices)")
    parser.add_argument("--perf", action="store_true", help="Enable performance tracking (gfxinfo/meminfo/cpuinfo)")
    parser.add_argument("--trace", action="store_true", help="Enable Perfetto system tracing")
    args = parser.parse_args()

    session_name = args.session_name

    if not re.match(r"^[a-zA-Z0-9_-]+$", session_name):
        print("Error: session name must match [a-zA-Z0-9_-]+", file=sys.stderr)
        sys.exit(1)

    # Auto-stop existing session if lock file exists
    if os.path.exists(LOCK_FILE):
        with open(LOCK_FILE, "r") as f:
            old_lock = json.load(f)
        old_name = old_lock["session_name"]
        count = finalize_session(old_lock)
        print("Auto-stopped session '%s' (%d commands recorded)." % (old_name, count))

    # Create session directory
    session_dir = os.path.join(RECORDINGS_DIR, session_name)
    os.makedirs(session_dir, exist_ok=True)

    # Write lock file
    now = utcnow()
    started_at = format_timestamp(now)
    output_path = os.path.join(session_dir, "recording.jsonl")

    lock_data = {
        "session_name": session_name,
        "output_path": output_path,
        "started_at": started_at,
    }
    if args.prompt:
        lock_data["prompt"] = args.prompt
    if args.device:
        lock_data["device_serial"] = args.device
    if args.perf:
        lock_data["performance_tracking"] = True
    if args.trace:
        lock_data["perfetto_tracing"] = True
    with open(LOCK_FILE, "w") as f:
        json.dump(lock_data, f, indent=2)
        f.write("\n")

    # Create/truncate the .jsonl file
    with open(output_path, "w") as f:
        pass

    print("Recording started: '%s'" % session_name)
    print("Recording to: %s" % output_path)
    if args.perf:
        print("Performance tracking: enabled")
    if args.trace:
        print("Perfetto tracing: enabled")


if __name__ == "__main__":
    main()
